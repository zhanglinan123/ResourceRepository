# AR远程专家指导系统

# 先决条件

- Unity编辑器 Unity 2020.3.26f1c1
- 两台设备进行测试（一台作为工人端，一台作为专家端）
- 工人端为运行AR场景的移动设备：搭载 Android 7 或更高版本
- 专家端是Windows系统的PC端
- 使用开发者账户申请Agora App ID

> *本项目不使用token身份验证。*
> 

# 插件引用

## 专家端

- [Agora Video SDK for Unity](https://assetstore.unity.com/packages/tools/video/agora-video-sdk-for-unity-134502) 3.6.1.1
    
    实现视频通话
    
- Agora **[RTM1.4.8.hotfix-2.unitypackage](https://github.com/AgoraIO-Community/Agora-Unity-RTM-SDK/releases)**
    
    实现呼叫邀请
    

## 工人端

- AR Foundation 4.1.9
    
    实现AR功能
    
- ARCore XR Plugin 4.1.9
    
    打包安卓应用需要
    
- [Agora Video SDK for Unity](https://assetstore.unity.com/packages/tools/video/agora-video-sdk-for-unity-134502) 3.6.1.1
    
    实现视频通话
    
- Agora **[RTM1.4.8.hotfix-2.unitypackage](https://github.com/AgoraIO-Community/Agora-Unity-RTM-SDK/releases)**
    
    实现呼叫邀请
    
- [**3D WebView for Android and iOS (Web Browser)](https://assetstore.unity.com/packages/tools/gui/3d-webview-for-android-and-ios-web-browser-135383#releases)** 4.1
    
    实现3D形式渲染Web内容
    
- ****[TriLib 2 - Model Loading Package](https://assetstore.unity.com/packages/tools/modeling/trilib-2-model-loading-package-157548#releases)** 2.0.6
    
    实现加载云端模型数据
    

# AR Foudation安卓打包设置

1. 依次点击File - Build Settings - Player Settings ，跳转到Project Settings
    
    ![https://github.com/zhanglinan123/ResourceRepository/blob/main/Images/AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20(3).png?raw=true](https://github.com/zhanglinan123/ResourceRepository/blob/main/Images/AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20(3).png?raw=true)
    
2. 勾选ARCore
    
    ![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled.png)
    
3. 设置包名(Company Name + Product Name)
    
    ![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%201.png)
    
4. Player - Android - Other Settings - 删除Graphics APIs下的Vulkan
    
    ![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%202.png)
    
5. Player - Android - Other Settings - 设置Minimum API Level
    
    ![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%203.png)
    
6. 设置Scripting Backend和Target Architectures
    
    ![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%204.png)
    
7. 设置完成

# 工程描述

## 专家端（PC端）

![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%205.png)

- AgoraEngine：安装Agora相关插件后生成，存放用于实现RTC和RTM的脚本
- Resources：资源文件夹，存放如音频、images、预制件、UI等资源
- Scenes：场景文件夹
- Scripts：脚本文件夹

## 工人端（移动端）

![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%206.png)

- AgoraEngine：安装Agora相关插件后生成，存放用于实现RTC和RTM的脚本
- Materials：材质文件夹
- Meshes：网格体文件夹
- Resources：资源文件夹，存放如音频、images、预制件、UI等资源
- Scenes：场景文件夹
- Scripts：脚本文件夹
- Shaders：着色器文件夹
- StreamingAssets：流资产文件夹，此工程用于存放开源语音识别Vosk的语言模型
- Textures：纹理文件夹
- ThirdParty：第三方文件夹，此工程用于存放开源语音识别Vosk相关依赖
- TriLib：安装渲染云端模型插件TriLib后生成
- Vuplex：安装3D浏览器插件3D Webview后生成
- XR：安装AR相关插件后生成

# 功能模块

## 呼叫邀请

在一个完整的呼叫邀请过程中，主叫和被叫的呼叫邀请状态分别由 `LocalInvitation`
 和 `RemoteInvitation`来定义。任意客户端可以是主叫也可以是被叫。

> *本项目目前实现为：工人端作为主叫进行发送呼叫邀请、取消呼叫邀请；专家端作为被叫进行拒绝呼叫邀请、接收呼叫邀请。工人端的实现脚本为WorkerRtmChatManager.cs，专家端的实现脚本为ExpertRtmChatManager.cs*
> 

呼叫邀请主要有4个流程：

![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%207.png)

1. 发送呼叫邀请（针对主叫）
2. 取消呼叫邀请（针对主叫）
3. 接受呼叫邀请（针对被叫）
4. 拒绝呼叫邀请（针对被叫）

### 呼叫邀请的相关回调

[Agora Real-time Messaging (RTM)官方API文档](https://docs.agora.io/cn/Real-time-Messaging/API%20Reference/RTM_Unity/index.html)

```csharp
// 报告给主叫的回调
// 被叫已接受呼叫邀请。
callEventHandler.OnLocalInvitationAccepted = OnLocalInvitationAcceptedHandler;
// 呼叫邀请已被成功取消。
callEventHandler.OnLocalInvitationCanceled = OnLocalInvitationCanceledHandler;
// 呼叫邀请过程失败。
callEventHandler.OnLocalInvitationFailure = OnLocalInvitationFailureHandler;
// 被叫已收到呼叫邀请。
callEventHandler.OnLocalInvitationReceivedByPeer = OnLocalInvitationReceivedByPeerHandler;
// 被叫已拒绝呼叫邀请。
callEventHandler.OnLocalInvitationRefused = OnLocalInvitationRefusedHandler;

// 报告给被叫的回调
// 已接受呼叫邀请。
callEventHandler.OnRemoteInvitationAccepted = OnRemoteInvitationAcceptedHandler;
// 呼叫邀请已被主叫取消。
callEventHandler.OnRemoteInvitationCanceled = OnRemoteInvitationCanceledHandler;
callEventHandler.OnRemoteInvitationFailure = OnRemoteInvitationFailureHandler;
// 收到一条呼叫邀请。SDK 会同时返回一个 RemoteInvitation 对象供被叫管理。
callEventHandler.OnRemoteInvitationReceived = OnRemoteInvitationReceivedHandler;
// 已拒绝呼叫邀请。
callEventHandler.OnRemoteInvitationRefused = OnRemoteInvitationRefusedHandler;
```

### 发送呼叫邀请

1.主叫创建 LocalInvitation类型的呼叫邀请对象。

```csharp
localInvitation = callManager.CreateLocalCallInvitation(peerUid);
// 设置房间名
localInvitation.SetChannelId(ChannelName);
// 设置呼叫内容
localInvitation.SetContent("Calling You...hello");
```

2.主叫发送呼叫邀请。

```csharp
int rc = callManager.SendLocalInvitation(localInvitation);
```

3.被叫收到回调：OnRemoteInvitationReceived。执行对应的注册事件：获取房间名，加载场景。

```csharp
void OnRemoteInvitationReceivedHandler(RemoteInvitation remoteInvitation)
{
    // 获取房间名
		ChannelName = remoteInvitation.GetChannelId().ToString();
    // 加载场景
    SceneManager.LoadScene("ReceiveInvitationScene", LoadSceneMode.Single);
}
```

4.主叫收到回调：OnLocalInvitationReceivedByPeer。执行对应的注册事件。

```csharp
void OnLocalInvitationReceivedByPeerHandler(LocalInvitation localInvitation)
{
    // do something
}
```

### 取消呼叫邀请

1.主叫取消呼叫邀请

```csharp
int rc = callManager.CancelLocalInvitation(localInvitation);
```

2.被叫收到回调：OnRemoteInvitationCanceled。执行对应的注册事件：加载场景。

```csharp
void OnRemoteInvitationCanceledHandler(RemoteInvitation remoteInvitation)
{
    // 回到主场景
    SceneManager.LoadScene("MainScene", LoadSceneMode.Single);
}
```

3.主叫收到回调：OnLocalInvitationCanceled。执行对应的注册事件：加载场景。

```csharp
void OnLocalInvitationCanceledHandler(LocalInvitation localInvitation)
{
    // 回到专家列表场景
    SceneManager.LoadScene("ExpertListScene", LoadSceneMode.Single);
}
```

### 接受呼叫邀请

1.被叫从 OnRemoteInvitationReceived 回调获取 remoteInvitation

```csharp
void OnRemoteInvitationReceivedHandler(RemoteInvitation remoteInvitation)
{
		// 获取 remoteInvitation
    this.remoteInvitation = remoteInvitation;
    
}
```

2.被叫接受呼叫邀请，加入房间，加载场景。

```csharp
public void AcceptInvitePeer()
{
    // 接受呼叫邀请。
    int rc = callManager.AcceptRemoteInvitation(remoteInvitation);
    // 加入房间、跳转场景
    StartAgoraVideoMeeting startAgoraVideoMeeting = GameObject.Find("GameControl").GetComponent<StartAgoraVideoMeeting>();
    startAgoraVideoMeeting.StartMeeting(appId, ChannelName);
}
```

3.被叫收到回调：OnRemoteInvitationAccepted。执行对应的注册事件。

```csharp
void OnRemoteInvitationAcceptedHandler(RemoteInvitation remoteInvitation)
{
    // do something
}
```

4.主叫收到回调：OnLocalInvitationAccepted。执行对应的注册事件：加载场景，加入房间。

```csharp
void OnLocalInvitationAcceptedHandler(LocalInvitation localInvitation, string response)
{
    // 加入房间、跳转到主场景
    StartAgoraVideoMeeting startAgoraVideoMeeting = GameObject.Find("SendInvitationSceneGameController").GetComponent<StartAgoraVideoMeeting>();
    startAgoraVideoMeeting.StartMeeting(appId,ChannelName);
}
```

### 拒绝呼叫邀请

1.被叫从 OnRemoteInvitationReceived 回调获取RemoteInvitation呼叫邀请对象。

```csharp
void OnRemoteInvitationReceivedHandler(RemoteInvitation remoteInvitation)
{
		// 获取 remoteInvitation
    this.remoteInvitation = remoteInvitation;
}
```

2.被叫拒绝呼叫邀请，加载场景。

```csharp
public void RefuseInvitePeer()
{
    // 拒绝呼叫邀请。
    int rc = callManager.RefuseRemoteInvitation(remoteInvitation);
    // 回到主场景
    SceneManager.LoadScene("MainScene", LoadSceneMode.Single);
}
```

3.被叫收到回调：OnRemoteInvitationRefused。执行对应的注册事件。

```csharp
void OnRemoteInvitationRefusedHandler(RemoteInvitation remoteInvitation)
{
    // do something
}
```

4.主叫收到回调：OnLocalInvitationRefused。执行对应的注册事件：加载场景。

```csharp
void OnLocalInvitationRefusedHandler(LocalInvitation localInvitation, string response)
{
    string msg = string.Format("OnLocalInvitationRefused channel:{0}, callee:{1}", localInvitation.GetChannelId(), localInvitation.GetCalleeId());
    Debug.Log(msg);
    // 返回专家列表场景
    SceneManager.LoadScene("ExpertListScene", LoadSceneMode.Single);

}
```

## AR空间标注

### 功能描述

工人端在现场一线通过视频通话请求专家端的远程指导，专家端可以在远程对现场画面进行空间标注，标注内容能够锚定在真实世界中。

### 技术实现思路

1.获取专家端选择的标注类型，捕捉专家端在屏幕上的鼠标动作并记录鼠标坐标。

2.将标注数据（如标注类型和鼠标坐标）发送到工人端。

3.工人端收到标注数据，在3D空间中呈现。

### 消除不同设备导致的屏幕点偏移

*GC_RemoteAssist.cs*

专家端将屏幕坐标转为视口坐标

```csharp
public static Vector2 NormalizePoint(Vector3 screenPos)
{
    Vector3 vp = Camera.main.ScreenToViewportPoint(screenPos);
    return new Vector2(vp.x, vp.y);
}
```

*WorkerMainSceneGameController.cs*

工人端将视口坐标转为世界坐标

```csharp
Vector3 DeNormalizedPosition(Vector2 viewportPos, float distance)
{

    Vector3 pos = new Vector3(viewportPos.x, viewportPos.y);

    pos = Camera.main.ViewportToScreenPoint(pos);

    pos = new Vector3(pos.x, pos.y, distance);

    return Camera.main.ScreenToWorldPoint(pos);
}
```

### 标注类型

draw：一组坐标点

tag：单个坐标点

### 点类型

draw类型下的点类型有：

- 线条 line
- 矩形 rectangle

tag类型下的点类型有：

- 提示图标 tooltip
- 自增序号 orderNumber
- 自定义文字 customText
- 自定义图片 customPic

### 数据模型对象

```csharp
public class StreamMessageModel
{
    public string type;
    public Dictionary<string, object> pointInfo;
    public Dictionary<string, object> resource;
}
```

1. **draw类型：线条/矩形（基于LineRenderer）**
    
    标注类型为**draw**时，pointInfo中的data为一组点。line和rectangle基本一致，区别是rectangle类型的坐标数固定为4个。
    
    ```csharp
    {
    	"type": "draw",
    	"pointInfo": {
    		"type": "line",		//可选项：line，rectangle
    		"data": [{
    			"x": 0.480733961,	//视口坐标
    			"y": 0.5424057
    		}, {
    			"x": 0.4825688,
    			"y": 0.539143741
    		}, {
    			"x": 0.4825688,
    			"y": 0.5326198
    		}]
    	},
    	"resource": {
    		"type": "",
    		"data": ""
    	}
    }
    ```
    
2. **tag类型：图标，自定义文字，自定义图片**
    
    标注类型为**tag**时，pointInfo中的data为单个点。
    
    ```csharp
    {
    	"type": "tag",
    	"pointInfo": {
    		"type": "orderNumber",		// 可选tooltip，orderNumber，customText，customPic
    		"data": {
    			"x": 0.45321098,
    			"y": 0.5685016
    		}
    	},
    	"resource": {
    		"type": "local",	// 可选local，url，text
    		"data": "num_1"	// 当type为local时，data为Resource/Image下的图片名称，当type为url时，data为url地址，当type为text时，data为自定义文字标注内容
    	}
    }
    ```
    
3. 指令类型
    
    ```csharp
    {
    	"type": "clear",		// 清除标注指令
    	"pointInfo": {
    		"type": "",
    		"data": ""
    	},
    	"resource": {
    		"type": "",
    		"data": ""
    	}
    }
    ```
    

### 场景按钮管理

以专家端为例，每个按钮的On Click()事件都绑定了GlobalButtonHandler类的OnButtonClicked方法，通过传入的int类型的变量来区分每个按钮。

![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%208.png)

*GlobalButtonHandler.cs*

```csharp
public void OnButtonClicked(int mode)
{
    // 为各个按钮编写相应的响应逻辑
    if(mode == 0)
		{
		    // do something
		}    
}
```

### UI碰撞检测

专家端需要记录鼠标点击屏幕位置作为标注坐标，但是不希望在进行UI交互的时候记录坐标。因此通过*RayHitUIDetect脚本来检查，每次的鼠标点击是否按到UI。*

1. 确保Canvas下的UI子对象的层级为UI
    
    ![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%209.png)
    
2. 因为我们要在工人端画面上进行标注，所以需要将用于呈现工人端画面的Image组件MainImage的层级设置为Ignore Raycast，顾名思义此此层级会忽略UI射线。
    
    ![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%2010.png)
    
3. 获取挂载在Canvas下的GraphicRaycaster组件
    
    ```csharp
    graphicRaycaster = GameObject.Find("Canvas").GetComponent<GraphicRaycaster>();
    ```
    
4. 检查是否按到UI（射线碰撞到UI）
    
    按到UI，返回true，否则返回false。
    
    ```csharp
    public bool RayHitUI()
    {
        //Create the PointerEventData with null for the EventSystem
        PointerEventData ped = new PointerEventData(null);
        //Set required parameters, in this case, mouse position
        ped.position = Input.mousePosition;
        //Create list to receive all results
        List<RaycastResult> results = new List<RaycastResult>();
        //Raycast it
        graphicRaycaster.Raycast(ped, results);
    
        if (results.Count > 0)
        {
            // 5为UI层
            return results.Any(r => r.gameObject.layer == 5);
        }
        return false;
    }
    ```
    

### 数据获取（专家端）

*GC_RemoteAssist.cs*

1. 当鼠标按下时，如果按到UI，则返回
    
    ```csharp
    if (rayHitUIDetect.RayHitUI())
    {
        return;
    }
            
    				
    ```
    
2. 线条
    1. 当鼠标按住时，如果鼠标移动距离大于给定值，则将鼠标所在坐标存入列表
        
        ```csharp
        // 鼠标左键被按住
        if (Input.GetMouseButton(0))
        {
            
            // 获取鼠标坐标
            Vector3 pos = Input.mousePosition;
            if (DistanceToLastPoint(pos) > 0.05f)
            {
                lastPos = pos;
                BufferSendPoints(NormalizePoint(pos));
            }
        }
        ```
        
    2. 当列表的坐标数大于最大存储坐标个数时，向工人端发送数据
        
        ```csharp
        void BufferSendPoints(Vector2 pos)
        {
            linePoints.Add(new Vector2(pos.x, pos.y));
        
            if (linePoints.Count > BufferLength)
            {
                SendDrawing(linePoints);
            }
        }
        ```
        
    3. 当鼠标释放时，向工人端发送数据。
        
        ```csharp
        if (Input.GetMouseButtonUp(0))
        {
            // 鼠标释放时发送线条数据
            SendDrawing(linePoints);
        }
        ```
        
    4. 每次发送数据后，清空列表
        
        ```csharp
        linePoints = new List<Vector2>();
        ```
        
3. 矩形
    1. 鼠标按下时，记录鼠标坐标
        
        ```csharp
        // 按下鼠标左键
        if (Input.GetMouseButtonDown(0))
        {
            // 获取鼠标初始坐标
            clickMousePos = Input.mousePosition;
        }
        ```
        
    2. 鼠标释放时，根据`鼠标按下`和`鼠标释放`时的坐标计算出矩形四个顶点的坐标，向工人端发送数据
        
        ```csharp
        // 释放鼠标左键
        if (Input.GetMouseButtonUp(0))
        {
            // 根据鼠标按下和鼠标释放时的坐标计算出矩形四个顶点的坐标
            rectPoints = new List<Vector2>();
            rectPoints.Add(NormalizePoint(new Vector3(clickMousePos.x, clickMousePos.y, 0)));
            rectPoints.Add(NormalizePoint(new Vector3(clickMousePos.x, releaseMousePos.y, 0)));
            rectPoints.Add(NormalizePoint(new Vector3(releaseMousePos.x, releaseMousePos.y, 0)));
            rectPoints.Add(NormalizePoint(new Vector3(releaseMousePos.x, clickMousePos.y, 0)));
            rectPoints.Add(NormalizePoint(new Vector3(clickMousePos.x, clickMousePos.y, 0)));
            // 发送矩形数据流
            SendDrawing(rectPoints);
        }
        ```
        
4. 自定义文字
    1. 新建GenerateCustomText用于获取用户输入
        
        ![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%2011.png)
        
    2. 绑定确定和取消按钮的响应事件
        
        ```csharp
        GameObject.Find("SubmitButton").GetComponent<Button>().onClick.AddListener(() => SubmitCustomText());
        GameObject.Find("CancelButton").GetComponent<Button>().onClick.AddListener(CancelCustomText);
        ```
        
    3. 当鼠标按下时，记录鼠标所在坐标，将GenerateCustomText移动到鼠标点击位置
        
        ```csharp
        GameObject.Find("GenerateCustomText").transform.position = clickMousePos;
        ```
        
    4. 当按下确定按钮时，获取输入框文本内容
        
        ```csharp
        string customText = CustomTextInputField.GetComponent<InputField>().text;
        ```
        
    5. 向工人端发送鼠标坐标和文本内容
        
        ```csharp
        SendTextTag(NormalizePoint(clickMousePos), customText);
        ```
        
    6. 当按下取消按钮时，禁用包括GenerateCustomText在内的所有popup
        
        ```csharp
        CloseAllSidebarMenuPanel();
        ```
        
5. 自增序号
    
    效果：当类型为自增序号时，鼠标每点击一次，会生成一个序号标注，序号在1-9范围内循环
    
    1. 定义计数器变量用于自增序号计数
        
        ```csharp
        int orderNumberCount = 0;
        ```
        
    2. 按下鼠标左键，记录鼠标坐标，自增序号计数器加1，计算序号，向工人端发送鼠标位置和Image名称
        
        ```csharp
        // 按下鼠标左键
        if (Input.GetMouseButtonDown(0))
        {
        		// 记录鼠标坐标
        		clickMousePos = Input.mousePosition;
            // 自增序号计数器加1
            orderNumberCount++;
            // 计算序号：1-9步长为1的循环
            int num = orderNumberCount % 10;
            if (num == 0)
            {
                orderNumberCount++;
                num = orderNumberCount % 10;
            }
        
            // 拼接上序号组成要发送的Image名称，发送数据流
            SendImageTag(NormalizePoint(clickMousePos), "local", "num_" + num.ToString());
        }
        ```
        

### 数据组装（专家端）

实例化一个数据模型对象，填充数据

*GC_RemoteAssist.cs*

```csharp
StreamMessageModel streamMessageModel = new StreamMessageModel();
streamMessageModel.type = "draw";
streamMessageModel.pointInfo = new Dictionary<string, object>();
streamMessageModel.pointInfo.Add("type", pointType);
streamMessageModel.pointInfo.Add("data", Points);
streamMessageModel.resource = new Dictionary<string, object>();
streamMessageModel.resource.Add("type", "");
streamMessageModel.resource.Add("data", "");
```

通过Newtonsoft进行序列化：将数据模型对象转为json字符串

```csharp
string jsonString = JsonConvert.SerializeObject(streamMessageModel, new VectorConverter());
```

> *VectorConverter类可以正确序列化或反序列化Unity中的Vector数据，能够在转换时剔除多余的数据，只留下x、y、z坐标数据。*
> 

### 数据发送（专家端）

*GC_RemoteAssist.cs*

1. 创建数据流id
    
    ```csharp
    dataStreamId = mRtcEngine.CreateDataStream(true, true);
    ```
    
2. 向工人端发送json字符串数据（协程）
    
    ```csharp
    IEnumerator SendStreamMessage(string message)
    {
        byte[] data = System.Text.Encoding.UTF8.GetBytes(message);
        if (dataStreamId > 0)
        {
            // 发送数据流消息
            int res = mRtcEngine.SendStreamMessage(dataStreamId, data);
            Debug.Log("专家端发送结果(0成功，<0失败)：" + res);
        }
        yield return null;
    }
    ```
    

### 数据接收（工人端）

*WorkerMainSceneGameController.cs*

**注册当接收到对方数据流消息的回调**

```csharp
mRtcEngine.OnStreamMessage = OnStreamMessageHandler;
```

**在回调注册事件中对数据进行解析**

1. Newtonsoft反序列化： json字符串转对象
    
    ```csharp
    StreamMessageModel model = JsonConvert.DeserializeObject<StreamMessageModel>(data, new VectorConverter());
    ```
    
2. 解析点数据
    - 当类型为tag时，pointData类型为单个点，用于存放data数据的变量类型为Vector2；
        
        ```csharp
        JObject jObject = JObject.Parse(model.pointInfo["data"].ToString());
        singlePointData = jObject.ToObject<Vector2>();
        ```
        
    - 类型为draw时，pointData类型为一组点，用于存放data数据的变量类型为List<Vector2>；
        
        ```csharp
        JArray jArray = JArray.Parse(model.pointInfo["data"].ToString());
        multiplePointsData = jArray.ToObject<List<Vector2>>();
        ```
        

### 数据呈现（工人端）

*WorkerMainSceneGameController.cs*

1. 当收到的数据类型为清除指令时，清除所有AR标注
    
    ```csharp
    if (type == "clear")
    {
        Debug.Log("收到清空标注指令");
        GameObject drawSpace = GameObject.Find("RenderSpace");
        // draw标注的父对象
    		if (drawSpace)
        {
            DeleteChildren(drawSpace);
        }
        // tag标注的父对象
    		GameObject tagSpace = GameObject.Find("TagSpace");
        if (tagSpace)
        {
            DeleteChildren(tagSpace);
        }
    
    }
    ```
    
2. 当收到的数据类型为draw时，进行射线碰撞，将`碰撞距离`和`视口坐标数组`传递给CastLineRender.cs进行3D空间绘制。
    
    ```csharp
    if (type == "draw")
    {
        Debug.Log("收到draw类型标注");
        // 进行射线检测
        distance = getHitPoseZ();
        if (distance == 0.0f)
        {
            Debug.Log("未发生碰撞，默认距离为0.5");
            distance = 0.5f;
        }
        Debug.Log("点的个数:" + multiplePointsData.Count);
        // 绘制
        castLineRender.DrawRender(multiplePointsData, distance);
    }
    ```
    
3. 当收到的数据类型为tag时，进行射线碰撞，并将视口坐标转世界坐标，基于碰撞距离和世界坐标在3D空间生成标注
    
    ```csharp
    if (model.type.ToString() == "tag")
    {
        Debug.Log("收到tag类型标注");
        // 进行射线检测
        distance = getHitPoseZ();
        if (distance == 0.0f)
        {
            Debug.Log("未发生碰撞，默认距离为0.5");
            distance = 0.5f;
        }
    
        // 视口坐标转世界坐标
        Vector3 worldPos = DeNormalizedPosition(singlePointData, distance);
    
        if (pointType == "tooltip" || pointType == "orderNumber" || pointType == "customPic")
            // 生成图片tag
            SpawnImageTag(worldPos, resourceType, resourceData);
        if (pointType == "customText")
            // 生成文字tag
            SpawnTextTag(worldPos, resourceData);
    }
    ```
    
    [tag标注类型的呈现实现](https://www.notion.so/tag-d1c1f5c4e646485eb3319bd1e5ec95cd)
    

## 查看文档（工人端）

基于3D Webview插件，在3D空间生成浏览器，打开文档链接实现查看文档。

1. 安装插件
2. 将WebViewPrefab预制件拖入场景，设置position为(0,0,30)（因为AR Camera的远裁剪平面为20，所以z轴值为30的话，场景中不可见），设置Initial URL为任意国内可以访问的网址，设置Drag Mode为Disable以禁用拖动交互。
    
    ![Untitled](AR%E8%BF%9C%E7%A8%8B%E4%B8%93%E5%AE%B6%E6%8C%87%E5%AF%BC%E7%B3%BB%E7%BB%9F%20c1878082f7094785ae8f5ef7a0c0a442/Untitled%2012.png)
    
3. *MyWebviewUtil.cs*中实现了查看文档功能。
- 查看文档（打开一个pdf链接）
    
    ```csharp
    // 设置浏览器预制件位置使得在画面中可见
    _webViewPrefab.transform.position = DeNormalizedPosition(new Vector2(0.5f, 1.0f), 0.5f);
    // 设置浏览器预制件朝向摄像头
    _webViewPrefab.transform.rotation = Camera.main.transform.rotation;
    // 加载网页
    _webViewPrefab.WebView.LoadUrl("https://file.keking.cn/onlinePreview?url=aHR0cHM6Ly9maWxlLmtla2luZy5jbi9kZW1vLzU1NTU2Ni5kb2N4");
    ```
    
- 关闭文档（更改浏览器预制件位置为AR Camera摄像头远裁剪平面外使得在画面不可见）
    
    ```csharp
    _webViewPrefab.transform.position = new Vector3(0, 0, 30);
    ```
    
- 控制文档：下一页/上一页/放大/缩小（向浏览器预制件发送JavaScript）
    
    ```csharp
    // 浏览器自带pdf解析文档下一页
    _webViewPrefab.WebView.ExecuteJavaScript("document.getElementById('next').click();");
    ```
    

## 语音识别与交互（工人端）

[使用vosk实现Unity语音识别与交互](https://www.notion.so/vosk-Unity-af0a53c4839342d183ea6e3f8817cb9b)

## 加载云端模型数据（工人端）

[使用TriLib 2插件实现加载云端模型数据](https://www.notion.so/TriLib-2-2d53332a4f744d0884d228e12c4d6cec)

## OCR识别（专家端）

因为工人端推流过来的画面纹理旋转了180°，因此需要将纹理转为纹理2D，再进行旋转180°进行OCR识别，识别文本会以弹窗形式展示，再绑定弹窗的关闭按钮监听，实现点击关闭按钮关闭弹窗的效果。

*GC_RemoteAssist.cs*

1. 准备目标图片

```csharp
GameObject go = GameObject.Find("MainImage");
Texture tex = go.GetComponent<RawImage>().texture;
// Texture转Texture2D
Texture2D tex2D = tex as Texture2D;
// 旋转180度
tex2D = RotateTexture2D.RotateSquare(tex2D, 180f);
// OCR识别
string result = OCRRequest.accurateBasic(apiKey, secretKey, tex2D);
Debug.Log(result);
// 弹出弹窗
ToggleActive(OCRTextPanel);
// 设置识别文本
GameObject.Find("OCRText").GetComponent<Text>().text = result;
// 添加关闭弹窗文本点击监听
GameObject.Find("CloseText").GetComponent<Button>().onClick.AddListener(CloseOCRTextPanel);
```

1. 调用百度OCR接口

```csharp
public static string accurateBasic(string apiKey, string secretKey, Texture2D texture)
{
    string token = getAccessToken(apiKey, secretKey);
    string host = "https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic?access_token=" + token;
    Encoding encoding = Encoding.Default;
    HttpWebRequest request = (HttpWebRequest)WebRequest.Create(host);
    request.Method = "post";
    request.KeepAlive = true;
    // 图片的base64编码
    string base64 = Texture2DToBase64(texture);
    String str = "image=" + HttpUtility.UrlEncode(base64);
    byte[] buffer = encoding.GetBytes(str);
    request.ContentLength = buffer.Length;
    request.GetRequestStream().Write(buffer, 0, buffer.Length);
    HttpWebResponse response = (HttpWebResponse)request.GetResponse();
    StreamReader reader = new StreamReader(response.GetResponseStream(), Encoding.Default);
    string result = reader.ReadToEnd();
    Console.WriteLine("通用文字识别（高精度版）:");
    Console.WriteLine(result);
    Debug.Log(result);
    // 转为对象
    JObject fullDataJO = JObject.Parse(result);
    // 转为数组
    JArray recJA = JArray.Parse(fullDataJO["words_result"].ToString());
    string recResult = "";
    //Debug.Log(recJA.Count);
    if (recJA.Count > 0)
    {
        // 获取识别结果
        for(int i = 0; i < recJA.Count; i++)
        {
            recResult = recResult + recJA[i]["words"].ToString();
        }
        return recResult;
    }
    else
    {
        return "识别失败";
    }
    
}
```

## 屏幕共享（专家端）

*GC_RemoteAssist.cs*

### 开始共享屏幕

```csharp
private void OnStartShareBtnClick()
{
    if (_startShareBtn != null) _startShareBtn.gameObject.SetActive(false);
    if (_stopShareBtn != null) _stopShareBtn.gameObject.SetActive(true);
		
		// 停止屏幕捕捉
    mRtcEngine.StopScreenCapture();
  
    if (_winIdSelect == null) return;
    var option = _winIdSelect.options[_winIdSelect.value].text;
    if (string.IsNullOrEmpty(option)) return;
    if (option.Contains("|"))
    {
        var windowId = option.Split("|".ToCharArray(), StringSplitOptions.RemoveEmptyEntries)[1];
        Debug.Log(string.Format(">>>>> Start sharing {0}", windowId));
        mRtcEngine.StartScreenCaptureByWindowId(int.Parse(windowId), default(Rectangle),
            default(ScreenCaptureParameters));
    }
    else
    {
#if UNITY_EDITOR_OSX || UNITY_STANDALONE_OSX
        var dispId = uint.Parse(option.Split(" ".ToCharArray(), StringSplitOptions.RemoveEmptyEntries)[1]);
        _logger.UpdateLog(string.Format(">>>>> Start sharing display {0}", dispId));
        mRtcEngine.StartScreenCaptureByDisplayId(dispId, default(Rectangle),
        // 自定义ScreenCaptureParameters
            new ScreenCaptureParameters {captureMouseCursor = true, frameRate = 30});
#elif UNITY_EDITOR_WIN || UNITY_STANDALONE_WIN
        var diapFlag = uint.Parse(option.Split(" ".ToCharArray(), StringSplitOptions.RemoveEmptyEntries)[1]);
        var screenRect = new Rectangle
        {
            x = _dispRect[diapFlag].left,
            y = _dispRect[diapFlag].top,
            width = _dispRect[diapFlag].right - _dispRect[diapFlag].left,
            height = _dispRect[diapFlag].bottom - _dispRect[diapFlag].top
        };
        Debug.Log(string.Format(">>>>> Start sharing display {0}: {1} {2} {3} {4}", diapFlag, screenRect.x,
            screenRect.y, screenRect.width, screenRect.height));

        // ScreenCaptureParameters保持默认
        var ret = mRtcEngine.StartScreenCaptureByScreenRect(screenRect,
            new Rectangle { x = 0, y = 0, width = 0, height = 0 }, default(ScreenCaptureParameters));
#endif
    }
}
```

### 停止共享

*GC_RemoteAssist.cs*

```csharp
private void OnStopShareBtnClick()
    {
        if (_startShareBtn != null) _startShareBtn.gameObject.SetActive(true);
        if (_stopShareBtn != null) _stopShareBtn.gameObject.SetActive(false);
        mRtcEngine.StopScreenCapture();
    }
```